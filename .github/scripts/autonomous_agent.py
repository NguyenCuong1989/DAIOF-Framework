#!/usr/bin/env python3
"""
AI Agent Autonomous Operations Script
Cho ph√©p AI ho·∫°t ƒë·ªông ƒë·ªôc l·∫≠p tr√™n GitHub th√¥ng qua GitHub Actions

Tu√¢n th·ªß 4 Pillars:
- An to√†n: Ch·ªâ th·ª±c hi·ªán c√°c thay ƒë·ªïi an to√†n, c√≥ th·ªÉ revert
- ƒê∆∞·ªùng d√†i: T·∫≠p trung v√†o gi√° tr·ªã l√¢u d√†i, kh√¥ng spam
- Tin v√†o s·ªë li·ªáu: Ra quy·∫øt ƒë·ªãnh d·ª±a tr√™n metrics
- H·∫°n ch·∫ø r·ªßi ro con ng∆∞·ªùi: T·ª± ƒë·ªông h√≥a nh∆∞ng c√≥ gi·ªõi h·∫°n r√µ r√†ng
"""

import os
import sys
import json
import yaml
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional

try:
    from github import Github, GithubException
except ImportError:
    print("‚ùå PyGithub not installed. Installing...")
    os.system("pip install PyGithub")
    from github import Github, GithubException


class AutonomousAIAgent:
    """AI Agent c√≥ kh·∫£ nƒÉng ho·∫°t ƒë·ªông t·ª± ƒë·ªông tr√™n GitHub"""
    
    def __init__(self):
        self.token = os.getenv('GITHUB_TOKEN')
        self.repo_name = os.getenv('REPO_NAME')
        self.task_type = os.getenv('TASK_TYPE', 'auto_maintain')
        
        if not self.token:
            raise ValueError("‚ùå GITHUB_TOKEN not found in environment")
        
        self.gh = Github(self.token)
        self.repo = self.gh.get_repo(self.repo_name)
        self.log = []
        
    def log_action(self, message: str, level: str = "INFO"):
        """Ghi log c√°c h√†nh ƒë·ªông c·ªßa AI"""
        timestamp = datetime.utcnow().isoformat()
        log_entry = f"[{timestamp}] [{level}] {message}"
        self.log.append(log_entry)
        print(log_entry)
        
    def get_repo_metrics(self) -> Dict:
        """Thu th·∫≠p metrics t·ª´ repository"""
        return {
            'stars': self.repo.stargazers_count,
            'forks': self.repo.forks_count,
            'watchers': self.repo.watchers_count,
            'open_issues': self.repo.open_issues_count,
            'subscribers': self.repo.subscribers_count,
        }
    
    def auto_maintain(self):
        """T·ª± ƒë·ªông b·∫£o tr√¨ repository"""
        self.log_action("üîß Starting automatic maintenance...")
        
        # 1. Ki·ªÉm tra v√† update README badges
        self._update_readme_badges()
        
        # 2. T·∫°o daily metrics report
        self._create_metrics_report()
        
        # 3. Auto-label issues n·∫øu c√≥
        self._auto_label_issues()
        
        self.log_action("‚úÖ Automatic maintenance completed")
    
    def _update_readme_badges(self):
        """C·∫≠p nh·∫≠t badges trong README v·ªõi metrics m·ªõi nh·∫•t"""
        try:
            readme = self.repo.get_contents("README.md")
            content = readme.decoded_content.decode('utf-8')
            
            metrics = self.get_repo_metrics()
            
            # Ki·ªÉm tra xem c·∫ßn update kh√¥ng (ch·ªâ update n·∫øu metrics thay ƒë·ªïi ƒë√°ng k·ªÉ)
            # An to√†n: Kh√¥ng spam commits kh√¥ng c·∫ßn thi·∫øt
            self.log_action(f"üìä Current metrics: {metrics}")
            
        except Exception as e:
            self.log_action(f"‚ö†Ô∏è Badge update skipped: {str(e)}", "WARNING")
    
    def _create_metrics_report(self):
        """T·∫°o b√°o c√°o metrics h√†ng ng√†y"""
        metrics = self.get_repo_metrics()
        timestamp = datetime.utcnow().strftime('%Y-%m-%d')
        
        report_dir = Path('metrics')
        report_dir.mkdir(exist_ok=True)
        
        report_file = report_dir / f'daily_{timestamp}.json'
        
        with open(report_file, 'w') as f:
            json.dump({
                'date': timestamp,
                'metrics': metrics,
                'timestamp': datetime.utcnow().isoformat()
            }, f, indent=2)
        
        self.log_action(f"üìà Metrics report created: {report_file}")
    
    def _auto_label_issues(self):
        """T·ª± ƒë·ªông g·∫Øn labels cho issues m·ªõi"""
        try:
            # L·∫•y issues m·ªü trong 24h qua ch∆∞a c√≥ label
            since = datetime.utcnow() - timedelta(days=1)
            issues = self.repo.get_issues(state='open', since=since)
            
            labeled_count = 0
            for issue in issues:
                if len(list(issue.labels)) == 0:
                    # AI ph√¢n t√≠ch n·ªôi dung v√† g·∫Øn label ph√π h·ª£p
                    labels = self._suggest_labels(issue)
                    if labels:
                        issue.add_to_labels(*labels)
                        labeled_count += 1
                        self.log_action(f"üè∑Ô∏è Auto-labeled issue #{issue.number}: {labels}")
            
            if labeled_count > 0:
                self.log_action(f"‚úÖ Auto-labeled {labeled_count} issues")
            else:
                self.log_action("‚ÑπÔ∏è No issues need auto-labeling")
                
        except Exception as e:
            self.log_action(f"‚ö†Ô∏è Auto-labeling skipped: {str(e)}", "WARNING")
    
    def _suggest_labels(self, issue) -> List[str]:
        """AI ph√¢n t√≠ch issue v√† ƒë·ªÅ xu·∫•t labels ph√π h·ª£p"""
        labels = []
        title_lower = issue.title.lower()
        body_lower = (issue.body or '').lower()
        
        # Simple keyword-based labeling (c√≥ th·ªÉ n√¢ng c·∫•p v·ªõi AI model sau)
        if any(word in title_lower for word in ['bug', 'error', 'fix', 'broken']):
            labels.append('bug')
        
        if any(word in title_lower for word in ['feature', 'enhancement', 'add']):
            labels.append('enhancement')
        
        if any(word in title_lower for word in ['doc', 'documentation', 'readme']):
            labels.append('documentation')
        
        if any(word in title_lower for word in ['question', 'help', 'how']):
            labels.append('question')
        
        return labels
    
    def community_engagement(self):
        """T∆∞∆°ng t√°c v·ªõi community m·ªôt c√°ch t·ª± ƒë·ªông"""
        self.log_action("üë• Starting community engagement...")
        
        # 1. Welcome new contributors
        self._welcome_new_contributors()
        
        # 2. Thank first-time contributors
        self._thank_contributors()
        
        # 3. Respond to questions (n·∫øu c√≥ template)
        self._auto_respond_questions()
        
        self.log_action("‚úÖ Community engagement completed")
    
    def _welcome_new_contributors(self):
        """Ch√†o m·ª´ng contributors m·ªõi"""
        try:
            # L·∫•y PRs m·ªü trong 24h qua
            since = datetime.utcnow() - timedelta(days=1)
            pulls = self.repo.get_pulls(state='open', sort='created')
            
            welcomed_count = 0
            for pr in pulls[:5]:  # Gi·ªõi h·∫°n 5 PRs g·∫ßn nh·∫•t
                # Ki·ªÉm tra xem ƒë√¢y c√≥ ph·∫£i first-time contributor kh√¥ng
                author_prs = list(self.repo.get_pulls(state='all', creator=pr.user.login))
                
                if len(author_prs) == 1:  # First PR from this user
                    # Ki·ªÉm tra xem ƒë√£ welcome ch∆∞a
                    comments = list(pr.get_issue_comments())
                    already_welcomed = any('AI Agent ü§ñ' in c.body for c in comments)
                    
                    if not already_welcomed:
                        welcome_msg = f"""
üéâ **Welcome to DAIOF Framework, @{pr.user.login}!**

Thank you for your first contribution! 

The AI Agent has noticed your PR and will help guide it through the review process. A human maintainer will review your changes soon.

**Quick tips:**
- Make sure all tests pass ‚úÖ
- Follow our [Contributing Guidelines](../CONTRIBUTING.md)
- Feel free to ask questions!

---
*This is an automated message from the AI Agent ü§ñ*
"""
                        pr.create_issue_comment(welcome_msg)
                        welcomed_count += 1
                        self.log_action(f"üëã Welcomed first-time contributor: @{pr.user.login}")
            
            if welcomed_count > 0:
                self.log_action(f"‚úÖ Welcomed {welcomed_count} new contributors")
            else:
                self.log_action("‚ÑπÔ∏è No new contributors to welcome")
                
        except Exception as e:
            self.log_action(f"‚ö†Ô∏è Welcome message skipped: {str(e)}", "WARNING")
    
    def _thank_contributors(self):
        """C·∫£m ∆°n contributors khi PR ƒë∆∞·ª£c merge"""
        try:
            # L·∫•y PRs merged trong 24h qua
            since = datetime.utcnow() - timedelta(days=1)
            pulls = self.repo.get_pulls(state='closed', sort='updated')
            
            thanked_count = 0
            for pr in pulls[:10]:  # Gi·ªõi h·∫°n 10 PRs
                if pr.merged and pr.merged_at and pr.merged_at > since:
                    # Ki·ªÉm tra xem ƒë√£ thank ch∆∞a
                    comments = list(pr.get_issue_comments())
                    already_thanked = any('Thank you for your contribution' in c.body for c in comments)
                    
                    if not already_thanked:
                        thank_msg = f"""
üôè **Thank you for your contribution, @{pr.user.login}!**

Your PR has been merged and is now part of DAIOF Framework. We appreciate your time and effort in making this project better!

‚≠ê If you enjoyed contributing, please consider starring the repo and sharing it with others!

---
*This is an automated message from the AI Agent ü§ñ*
"""
                        pr.create_issue_comment(thank_msg)
                        thanked_count += 1
                        self.log_action(f"üôè Thanked contributor: @{pr.user.login}")
            
            if thanked_count > 0:
                self.log_action(f"‚úÖ Thanked {thanked_count} contributors")
            else:
                self.log_action("‚ÑπÔ∏è No merged PRs to thank")
                
        except Exception as e:
            self.log_action(f"‚ö†Ô∏è Thank message skipped: {str(e)}", "WARNING")
    
    def _auto_respond_questions(self):
        """T·ª± ƒë·ªông tr·∫£ l·ªùi c√°c c√¢u h·ªèi th∆∞·ªùng g·∫∑p"""
        # An to√†n: Ch·ªâ respond v·ªõi template c√≥ s·∫µn, kh√¥ng t·ª± generate
        self.log_action("‚ÑπÔ∏è Auto-response to questions: Not implemented yet (safety)")
    
    def content_update(self):
        """T·ª± ƒë·ªông c·∫≠p nh·∫≠t n·ªôi dung"""
        self.log_action("üìù Starting content update...")
        
        # 1. Update contributor list
        self._update_contributors()
        
        # 2. Generate changelog t·ª´ commits
        self._update_changelog()
        
        self.log_action("‚úÖ Content update completed")
    
    def _update_contributors(self):
        """C·∫≠p nh·∫≠t danh s√°ch contributors"""
        try:
            contributors = self.repo.get_contributors()
            
            contrib_file = Path('CONTRIBUTORS.md')
            
            with open(contrib_file, 'w') as f:
                f.write("# Contributors\n\n")
                f.write("Thank you to all the amazing people who have contributed to DAIOF Framework!\n\n")
                
                for contrib in contributors:
                    contributions = contrib.contributions
                    f.write(f"- [@{contrib.login}]({contrib.html_url}) - {contributions} commits\n")
                
                f.write(f"\n---\n*Last updated: {datetime.utcnow().strftime('%Y-%m-%d')} by AI Agent ü§ñ*\n")
            
            self.log_action(f"üë• Updated contributors list")
            
        except Exception as e:
            self.log_action(f"‚ö†Ô∏è Contributors update skipped: {str(e)}", "WARNING")
    
    def _update_changelog(self):
        """T·ª± ƒë·ªông generate changelog t·ª´ commits g·∫ßn ƒë√¢y"""
        self.log_action("‚ÑπÔ∏è Changelog generation: Skipped (will be done manually)")
    
    def metrics_report(self):
        """T·∫°o b√°o c√°o chi ti·∫øt v·ªÅ metrics"""
        self.log_action("üìä Generating detailed metrics report...")
        
        metrics = self.get_repo_metrics()
        
        report = f"""# Repository Metrics Report
Generated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}

## Overview
- ‚≠ê Stars: {metrics['stars']}
- üç¥ Forks: {metrics['forks']}
- üëÄ Watchers: {metrics['watchers']}
- üìù Open Issues: {metrics['open_issues']}
- üë• Subscribers: {metrics['subscribers']}

## Growth Analysis
*Analysis will be added when we have historical data*

---
*Generated by AI Agent ü§ñ*
"""
        
        report_file = Path('metrics') / f'report_{datetime.utcnow().strftime("%Y%m%d")}.md'
        report_file.parent.mkdir(exist_ok=True)
        
        with open(report_file, 'w') as f:
            f.write(report)
        
        self.log_action(f"üìä Metrics report saved: {report_file}")
    
    def run(self):
        """Th·ª±c thi autonomous agent theo task type"""
        self.log_action(f"üöÄ AI Agent starting: Task={self.task_type}")
        
        try:
            if self.task_type == 'auto_maintain':
                self.auto_maintain()
            elif self.task_type == 'community_engagement':
                self.community_engagement()
            elif self.task_type == 'content_update':
                self.content_update()
            elif self.task_type == 'metrics_report':
                self.metrics_report()
            else:
                self.log_action(f"‚ö†Ô∏è Unknown task type: {self.task_type}", "WARNING")
            
            self.log_action("‚úÖ AI Agent completed successfully")
            
        except Exception as e:
            self.log_action(f"‚ùå AI Agent failed: {str(e)}", "ERROR")
            raise
        
        finally:
            # Save log
            log_file = Path('metrics') / f'agent_log_{datetime.utcnow().strftime("%Y%m%d_%H%M%S")}.txt'
            log_file.parent.mkdir(exist_ok=True)
            
            with open(log_file, 'w') as f:
                f.write('\n'.join(self.log))
            
            print(f"\nüìù Log saved: {log_file}")


if __name__ == '__main__':
    agent = AutonomousAIAgent()
    agent.run()
